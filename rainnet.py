# -*- coding: utf-8 -*-
"""rainnet

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dLfUgLGY5CO1D0HSAIGNQbHtS7fyATL4

- rainnet
- epoch = 20, k-fold = 5, dropout = 0.5, start_node = 32
"""

from google.colab import drive
drive.mount('/content/drive')

!nvidia-smi

!curl ipinfo.io

"""# 새 섹션"""

path = '/content/drive/My Drive/강우예측AI'

import zipfile
 
zip_file = zipfile.ZipFile(path+'/train.zip')
zip_file.extractall('.')
 
zip_file = zipfile.ZipFile(path+'/test.zip')
zip_file.extractall('.')

import glob
import pandas as pd
import numpy as np
import matplotlib.pylab as plt
from tqdm import tqdm
import tensorflow as tf
from tensorflow.keras.layers import Conv2D, Conv2DTranspose, MaxPooling2D, BatchNormalization, concatenate, Input
from tensorflow.keras import Model
import os
import warnings
warnings.filterwarnings("ignore")

from keras.models import *
from keras.layers import *

train_files = glob.glob('/content/train/*.npy')
len(train_files)
train_files = np.array(train_files)

"""## 훈련 데이터 및 테스트 데이터생성"""

def trainGenerator():
    for file in train_files:
        dataset = np.load(file)
        target= dataset[:,:,-1].reshape(120,120,1)
        remove_minus_target = np.where(target < 0, 0, target)
        feature = dataset[:,:,:4]
 
        yield (feature, remove_minus_target)
        
train_dataset = tf.data.Dataset.from_generator(trainGenerator, (tf.float32, tf.float32), (tf.TensorShape([120,120,4]),tf.TensorShape([120,120,1])))
train_dataset = train_dataset.batch(256).prefetch(1)

test_files = sorted(glob.glob('./*.npy'))
 
X_test = []
 
for file in tqdm(test_files, desc = 'test'):
    data = np.load(file)
    X_test.append(data)
 
X_test = np.array(X_test)

def valGenerator():
    for file in val_file:
        dataset = np.load(file)
        target= dataset[:,:,-1].reshape(120,120,1)        
        remove_minus = np.where(target < 0, 0, target)
        feature = dataset[:,:,:4]


        yield (feature, remove_minus)

"""## 모델 정의

- 향후 model.load_weights()를 활용해서 훈련한 모델을 불러온다.
"""

def rainnet(input_shape=(120,120,4), mode="regression"):#epoch 20 k 5
 
    inputs = Input(input_shape)
 
    conv2s = Conv2D(32, 3, padding='same', kernel_initializer='he_normal')(inputs)
    conv2s = Activation("relu")(conv2s)
    conv2s = BatchNormalization()(conv2s)
    pool2 = MaxPooling2D(pool_size=(2, 2))(conv2s)
 
    conv3s = Conv2D(64, 3, padding='same', kernel_initializer='he_normal')(pool2)
    conv3s = Activation("relu")(conv3s)
    pool3 = BatchNormalization()(conv3s)
    pool3 = MaxPooling2D(pool_size=(2, 2))(conv3s)
 
    conv4s = Conv2D(128, 3, padding='same', kernel_initializer='he_normal')(pool3)
    conv4s = Activation("relu")(conv4s)
    conv4s = BatchNormalization()(conv4s)
    drop4 = Dropout(0.5)(conv4s)
 
    up7 = concatenate([Conv2DTranspose(128, (3, 3), strides=(2, 2), padding="same")(drop4), conv3s], axis=3)
    conv7 = Conv2D(64, 3, padding='same', kernel_initializer='he_normal')(up7)
    conv7 = Activation("relu")(conv7)
    conv7 = BatchNormalization()(conv7)
 
    up8 = concatenate([Conv2DTranspose(64, (3, 3), strides=(2, 2), padding="same")(conv7), conv2s], axis=3)
    conv8 = Conv2D(32, 3, padding='same', kernel_initializer='he_normal')(up8)
    conv8 = Activation("relu")(conv8)
    conv8 = BatchNormalization()(conv8)
 
    if mode == "regression":
        outputs = Conv2D(1, 1, activation='linear')(conv8)
    elif mode == "segmentation":
        outputs = Conv2D(1, 1, activation='sigmoid')(conv8)
 
    model = Model(inputs=inputs, outputs=outputs)
 
    return model

"""## 학습 (KFOLD적용)
- 기존 레인넷에서 한
"""

import gc
from sklearn.model_selection import KFold
kf = KFold(n_splits=5, random_state=42)

for fold, (train, val) in enumerate(kf.split(train_files)):
  #print(type(val))
  val_file = train_files[val]
  tr_file = train_files[train]
  

  train_dataset = tf.data.Dataset.from_generator(trainGenerator, (tf.float32, tf.float32), (tf.TensorShape([120,120,4]),tf.TensorShape([120,120,1])))
  train_dataset = train_dataset.shuffle(256)

  train_dataset = train_dataset.batch(128).prefetch(1)

  val_dataset = tf.data.Dataset.from_generator(valGenerator, (tf.float32, tf.float32), (tf.TensorShape([120,120,4]),tf.TensorShape([120,120,1])))
  val_dataset = val_dataset.batch(128).prefetch(1)

  

  model = rainnet(mode='regression')
  adam = tf.keras.optimizers.Adam()
  model.compile(optimizer=adam, loss='mae')


  callbacks = tf.keras.callbacks.ReduceLROnPlateau(
    monitor='val_loss', factor=0.2, patience=3, verbose=0, mode='min',
    min_delta=0.0001, cooldown=0, min_lr=0
  )
  sv = tf.keras.callbacks.ModelCheckpoint(
        os.path.join(path,f'{fold}-rain.h5'), monitor='val_loss', verbose=0, save_best_only=True,
        save_weights_only=True, mode='min', save_freq='epoch')

  model.fit(train_dataset, epochs = 20, verbose=1, validation_data=val_dataset, callbacks=[callbacks, sv])

  del model
  gc.collect()

model = rainnet(mode='regression')

import gc
from sklearn.model_selection import KFold
from sklearn.metrics import mean_absolute_error
def loss(final_X_answers, final_X_pred):
  pred = final_X_pred
  answer = final_X_answers
  mae = mean_absolute_error(answer, pred)
  print(mae)

from sklearn.model_selection import KFold
kf = KFold(n_splits=5, random_state=42)
total_val = []
total_answer = []
test_preds = []

for fold, (train, val) in enumerate(kf.split(train_files)):

  val_file = train_files[val]

  X_val = []
  X_answers = []
  
  for file in tqdm(val_file, desc='val'):
    data = np.load(file)
    X_answer = data[:,:,-1].reshape(14400)
    X_input = data[:,:,:4]
  
    X_val.append(X_input)
    X_answers.append(X_answer)
  X_val = np.array(X_val)
  X_answers = np.array(X_answers)
  model.load_weights(os.path.join(path,f'{fold}-rain.h5'))

  val_pred = model.predict(X_val)
  test_pred = model.predict(X_test)

  test_pred = test_pred.reshape(-1,14400)
  final_X_val = val_pred.reshape(-1,14400)
  total_val.append(final_X_val)
  total_answer.append(X_answers)
  test_preds.append(test_pred)
  
  del val_pred, X_val, X_answers, final_X_val
  gc.collect()

total_val[0]

final_val = np.reshape(np.array(total_val[0]), (1*12547,14400))
final_answer = np.reshape(np.array(total_answer[0]),(1*12547,14400))
loss(final_answer, final_val)

final_val = np.reshape(np.array(total_val[1]), (1*12547,14400))
final_answer = np.reshape(np.array(total_answer[1]),(1*12547,14400))
loss(final_answer, final_val)

final_preds = (test_preds[0]+test_preds[1]+test_preds[2]+test_preds[3]+test_preds[4])/5
sub = pd.read_csv(path+"/sample_submission.csv")
sub.iloc[:,1:] = final_preds.astype(int)
sub.to_csv("submission.csv", index=False)
from google.colab import files
submission = pd.read_csv('/content/drive/My Drive/강우예측AI/sample_submission.csv')
submission.to_csv(path + '/rainnet7_e20k5.csv', index = False)
files.download('submission.csv')

from matplotlib.p

tf.keras.utils.plot_model(model=model, show_shapes=True)

"""#학습 지원 기술"""

class LossAndErrorPrintingCallback(tf.keras.callbacks.Callback):
    def on_train_batch_end(self, batch, logs=None):
        print("For batch {}, loss is {:7.2f}.".format(batch, logs["loss"]))

    def on_test_batch_end(self, batch, logs=None):
        print("For batch {}, loss is {:7.2f}.".format(batch, logs["loss"]))

    def on_epoch_end(self, epoch, logs=None):
        print(
            "The average loss for epoch {} is {:7.2f} "
            "and mean absolute error is {:7.2f}.".format(
                epoch, logs["loss"], logs["mean_absolute_error"]
            )
        )

class EarlyStoppingAtMinLoss(tf.keras.callbacks.Callback):
    """Stop training when the loss is at its min, i.e. the loss stops decreasing.

  Arguments:
      patience: Number of epochs to wait after min has been hit. After this
      number of no improvement, training stops.
  """

    def __init__(self, patience=0):
        super(EarlyStoppingAtMinLoss, self).__init__()
        self.patience = patience
        # best_weights to store the weights at which the minimum loss occurs.
        self.best_weights = None

    def on_train_begin(self, logs=None):
        # The number of epoch it has waited when loss is no longer minimum.
        self.wait = 0
        # The epoch the training stops at.
        self.stopped_epoch = 0
        # Initialize the best as infinity.
        self.best = np.Inf

    def on_epoch_end(self, epoch, logs=None):
        current = logs.get("loss")
        if np.less(current, self.best):
            self.best = current
            self.wait = 0
            # Record the best weights if current results is better (less).
            self.best_weights = self.model.get_weights()
        else:
            self.wait += 1
            if self.wait >= self.patience:
                self.stopped_epoch = epoch
                self.model.stop_training = True
                print("Restoring model weights from the end of the best epoch.")
                self.model.set_weights(self.best_weights)

    def on_train_end(self, logs=None):
        if self.stopped_epoch > 0:
            print("Epoch %05d: early stopping" % (self.stopped_epoch + 1))

class CustomLearningRateScheduler(tf.keras.callbacks.Callback):
    """Learning rate scheduler which sets the learning rate according to schedule.

  Arguments:
      schedule: a function that takes an epoch index
          (integer, indexed from 0) and current learning rate
          as inputs and returns a new learning rate as output (float).
  """

    def __init__(self, schedule):
        super(CustomLearningRateScheduler, self).__init__()
        self.schedule = schedule

    def on_epoch_begin(self, epoch, logs=None):
        if not hasattr(self.model.optimizer, "lr"):
            raise ValueError('Optimizer must have a "lr" attribute.')
        # Get the current learning rate from model's optimizer.
        lr = float(tf.keras.backend.get_value(self.model.optimizer.learning_rate))
        # Call schedule function to get the scheduled learning rate.
        scheduled_lr = self.schedule(epoch, lr)
        # Set the value back to the optimizer before this epoch starts
        tf.keras.backend.set_value(self.model.optimizer.lr, scheduled_lr)
        print("\nEpoch %05d: Learning rate is %6.4f." % (epoch, scheduled_lr))


LR_SCHEDULE = [
    # (epoch to start, learning rate) tuples
    (3, 0.05),
    (6, 0.01),
    (9, 0.005),
    (12, 0.001),
]


def lr_schedule(epoch, lr):
    """Helper function to retrieve the scheduled learning rate based on epoch."""
    if epoch < LR_SCHEDULE[0][0] or epoch > LR_SCHEDULE[-1][0]:
        return lr
    for i in range(len(LR_SCHEDULE)):
        if epoch == LR_SCHEDULE[i][0]:
            return LR_SCHEDULE[i][1]
    return lr

